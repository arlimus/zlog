#!/usr/bin/env ruby
require 'zlog'
require 'optparse'

options = {}
OptionParser.new do |opts|
  opts.banner = "usage: zlog [options]\n       cat my.log | zlog [options]"

  opts.on("-f", "--file FILE", "Read log from file") do |file|
    options[:file] = file
  end

  opts.on("-s", "--simple", "Print simple layout") do |v|
    options[:format] = :simple
  end

  opts.on("-n", "--named", "Print simple layout with names") do |v|
    options[:format] = :named
  end
end.parse!

class Zlog::CLI
  def initialize opts = {}
    @layout = case opts[:format]
      when :named
        Zlog::Layouts.named
      else
        Zlog::Layouts.simple
      end
  end

  def convert_line line, opts = {}
    e = Zlog::json_2_event(line)
    if not e.nil?
      @layout.format(e)
    end
  end

  def convert_stdin opts = {}, &handler
    # collect all results to an array which will be returned
    # in case that no block is given for processing
    res = []
    handler = lambda{|line| res.push line} if not block_given?

    # process each line
    STDIN.readlines.each do |line|
      handler.( convert_line line, opts )
    end

    # return the result, in case we have any
    res
  end
end

cli = Zlog::CLI.new options
print_out = lambda{ |line| puts line }

if STDIN.tty?
  File::readlines( options[:file] ).each do |line|
    print_out.( cli.convert_line line )
  end
else
  cli.convert_stdin &print_out
end